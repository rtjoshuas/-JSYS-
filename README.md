# 운영체제


컴퓨터 시스템에서 사용자 인터페이스, 시스템 자원, 프로세스 관리를 담당하는 프로그램이다.

운영체제는 컴퓨터가 시작할 때(부트될 때) 처음 메모리에 적재되는 프로그램이며 계속 메모리에 남아서 컴퓨터에서 실행되는 다른 모든 프로그램을 적재하고 감독하는 역할을 수행한다.

모든 운영체제는 기본적으로 같은 기능을 수행한다. 기본 기능은 다음과 같다.
	사용자 인터페이스 제공
	프로세스 관리
	자원 관리
	보안 제공


## 1. 프로세스 관리

운영 체제는 컴퓨터상에서 프로세스(또는 프로그램)을 메모리에 적재하고, 시작시키거나 정지시키는 역할을 수행한다. 실행시키는 프로그램 각각을 프로세스(Process)라고 한다. 프로세스는 자신을 지원하도록 하기 위해 또 다른 프로세스를 시작(때때로 생성이라 불림)시키기도 한다.[그림]
-	프로세스 : 컴퓨터에서 실행중인 프로그램을 의미하며 더 큰 프로그램의 일부분일 수도 있다.

Windows에서 실행중인 프로세스를 보기 위해서는 작업 관리자(Task Manager) 윈도우를 열기 위해 Ctrl+Alt+Del 키 조합을 누른 후, 현재 실행중인 프로세스에 관련된 정보를 디스플레이하기 위해 프로세스 탭을 선택하면 된다.[그림]

DOS에서는 현재 실행중인 프로세스들을 열거하는 명령이 없는데, 이는 DOS에서는 한번에 하나의 프로세스만 실행할 수 있기 때문이다. DOS는 한 사용자에 의해 한 번에 하나의 작업을 수행할 수 있도록 설계되어 있는 반면에 UNIX는 여러 명의 사용자와 다수의 작업을 수용할 수 있도록 설계되었다.

실제로는 모든 단일 CPU 시스템에서 한 번에 하나의 프로세스만 실행될 수 있다. 인터넷 검색과 동시에 노래를 듣고 파일을 다운로드를 동시에 실행하는 것은 마치 많은 프로세스가 동시에 실행중인 것처럼 보이지만 컴퓨터는 실제로 한 번에 하나의 프로세스만 실행한다. 폰 노이만 구조에서는 명령들의 순차적인 처리만을 지원한다. 따라서 각 사이클 마다 오직 한 프로그램의 한 명령만 실행되어 진다.

CPU, 메모리, 키보드, 모니터 네트워크 카드 등 컴퓨터 시스템의 구성 요소들은 각기 다른 속도로 동작한다. CPU가 가장 빠르며 초당 수십억 개의 명령을 실행할 수 있다. 메인 메모리는 좀 더 느리지만 초 당 수백만 번의 메모리 엑세스를 수행한다. 메모리나 다른 장치들은 CPU에 비하여 상대적으로 느리기 때문에 CPU는 대개 여유가 있다. 여유 시간을 사용하여 CPU는 각 프로세스 마다 돌아가면서 약간의 명령들을 실행한다. CPU를 공유하면서 여러 프로세스를 실행하는 기법을 시분할(time slicing)이라 부른다.

운영 체제는 어떤 프로세스가 실행될 준비가 되어 있고 어던 프로세스가 I/O 장치의 응답을 기다리는지 알고 있어야만 한다. Windows 환경에서 실행중인 프로세스의 정보를 살펴보거나 프로세스를 중단시키기 위한 특수한 경우에는 때때로 프로세스는 즉시 CPU시간을 할당 받아야 한다. 이러한 키 입력이 들어올 때 운영 체제가 이미 다른 프로세스에 시간을 할당한 경우에는 CPU 시간을 요구하는 프로세스가 CPU를 인터럽트하여 바로 처리를 요청할 수 있는 기능을 운영 체제가 지원하는데 이는 인터럽트 처리(interrupt handling)라고 불리는 과정에 의해 처리된다.
인터럽트는 프로그램이나 I/O 장치에 의해 시작될 수도 있다. 인터럽트가 발생할 때, CPU는 현재 일을 멈추고 인터럽트 처리기(interrupt handler)라 불리는 메모리 내 프로그램을 실행한다.
운영체제가 개개의 장치와 실행중인 프로세스 각각에 대하여 우선순위를 할당하고 관리한다. 한 프로세스가 다른 프로세스에 할당된 자원을 기다리면서 두 번째 프로세스가 첫 번째 프로세스에 할당된 자원을 기다리는 경우, 자원 관리는 더욱 어려워질 수 있다. 이러한 예외적인 상황을 교착생태라고 부른다. 운영 체제가 이를 인식하여 하나의 자원을 놓아줌으로써 이러한 교착상태를 풀어주는 기능이 없다면 프로세스의 처리는 멈추고 시스템은 꼼짝 못하게 된다. 비록 이러한 교착상태가 매우 드물게 발생하기는 하지만 운영 체제가 이에 대한 해결 방안을 제공하지 못한다면 시스템은 재부팅 없이는 처리를 계속할 수 없게 된다.
-	교착 상태 : 프로세스들과 I/O 장치들이 서로 상대방 자원의 사용을 기다리는 아주 예외적인 현상, OS의 개입이 없다면 이러한 상황은 끝없이 계속될 수 있다.


## 2. 메모리

### 1)	구조
폰 노이만 구조의 기본 요소 중의 하나는 인출 – 실행 사이클이다. 각각의 명령은 실행을 위하여 메모리로부터 인출되어 CPU로 들어간다. 전자 메모리는 이러한 구조와 컴퓨터 처리의 실행 속도를 규정하는 핵심요소이다.

메모리는 ROM(Read-only)와 RAM(Random access)의 두 가지로 구분할 수 있다.
ROM이라는 이름은 칩에 영구적으로 새겨져서 수정이 불가능하다는 것을 의미한다. 특수한 유형의 ROM은 특수 조건 하에 재기록이 가능하다. ROM은 주소 집합에 반응하여 요청된 데이터를 버스 상에 올려놓을 수 있다. ROM은 BIOS라고 불리는 마더보드 상에 있는 칩에서 사용된다. 이 BIOS는 컴퓨터를 위한 시작 프로그램과 기본적인 입출력 루틴을 제공하는 명령과 데이터를 포함하고 있다.

RAM은 순차적으로 읽혀질 필요가 없고 주소에 의해 메모리에 있는 어떤 위치도 접근 가능하므로 “임의(random)”라고 불린다. 메모리로부터 읽거나 쓰는 메모리이다. 또한 휘발성이다. 원하는 때에 변경될 수 있으며, 메모리에 저장된 데이터를 유지하기 위해서는 전원이 필요하다.

### 2)	관리
운영 체제의 또 다른 주요 기능은 메모리의 관리이다. 컴퓨터에서 실행중인 모든 프로그램과 프로세스는 메인 메모리 또는 RAM에 저장된다. 프로그램을 위한 데이터 역시 메모리에 저장된다. 사용자가 프로그램 실행을 위해 어떤 명령을 실행하면, 운영 체제는 메모리 빈 공간의 위치를 찾은 후 디스크로부터 그 메모리 주소로 프로그램을 적재한다.프로세스가 시작하고 끝남에 따라 운영 체제는 끊임없이 메모리를 관리하고 CPU와 대화하여 프로그램을 어디에서 실행시킬 지를 결정한다.

운영 체제는 실행 프로그램을 메모리의 어느 부분에 올릴지를 결정한다. 다중 프로그램의 환경에서 메모리에 프로그램을 넣어주고 다시 저장장치로 보내주고 하는 과정들을 모두 운영체제에서 담당하여 처리한다. 


	 20210516 심영섭 

인용 자료
Greg Anderson & David Ferro & Robert Hilton “ Connecting with Computer Science – 컴퓨터 배움터” Paju : 생능출판사, 2006, pp. 128-129, p. 171, pp. 177-181.









https://github.com/rtjoshuas/-JSYS-/blob/main/HelloJava.java


>// pachkage hello;
>
>public class HelloJava {
>
>	public static void main(String[] args)
  {
    		<li>System.out.println("Hello, Java");</li>
  }
>  
>}



https://github.com/rtjoshuas/-JSYS-/blob/main/FirstJava.java 


>// pachkage hello;
>
>public class FirstJava {
>
>	public static void main(String[] args)
  {
		<li>System.out.println("Hello, Java");</li>
		<li>System.out.println("안녕하세요. 자바");</li>
		<li>System.out.println("퇴근시간이 가까와져요");</li>
  	<li>// System.out.print("행복해요");</li>
		<li>// System.out.println("             끝!");</li>
  }
>  
>}



https://github.com/rtjoshuas/-JSYS-/blob/main/IntegerVariable.java


>public class IntegerVariable {
>
>	public static void main(String[] args)
  {
		<li>short sVal = 10;</li>
		<li>byte bVal = 20;</li>
		<li>System.out.println(sVal + bVal);</li>
  }
>
>}

